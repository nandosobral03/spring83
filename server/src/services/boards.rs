use super::{service_utils::{
    get_db_connection, validate_key, validate_signature, validate_timestamp, MyError,
}, deny_list::is_denied_key};
use chrono::{DateTime, FixedOffset};
use ed25519_dalek::*;
use mongodb::bson::{doc};
use serde::{Deserialize, Serialize};


pub async fn put_board(key: String, sig: String, body: String) -> Result<(), MyError> {
    validate_key(&key)?;
    board_is_empty(&body)?;
    let timestamp = validate_timestamp(&body)?;
    if is_denied_key(&key).await?{
        return Err(MyError {
            message: "Forbidden".to_string(),
            status: 403,
        });
    }
    validate_signature(&sig, &key, &body)?;
    save_board(&key, &body, &timestamp,&sig).await?;
    Ok(())
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Board {
    #[serde(rename = "_id")]
    pub key: String,
    pub body: String,
    pub timestamp: String,
    pub last_modified: String,
    pub signature: String,
}

async fn save_board(key: &str, body: &str, timestamp: &str, sig: &str) -> Result<(), MyError> {
    let client = get_db_connection().await?;

    let board = Board {
        key: key.to_string(),
        body: body.to_string(),
        timestamp: timestamp.to_string(),
        last_modified: chrono::Utc::now().to_rfc3339(),
        signature: sig.to_string(),
    };

    let existsing_board = client
        .collection::<Board>("boards")
        .find_one(doc! { "_id": key }, None)
        .await
        .map_err(|_| MyError {
            message: "Failed to get board".to_string(),
            status: 500,
        })?;
    if let Some(board) = existsing_board {
        if  chrono::DateTime::parse_from_rfc3339(&board.timestamp).unwrap() > chrono::DateTime::parse_from_rfc3339(timestamp).unwrap() {
            return Err(MyError {
                message: "Timestamp is older than existing board".to_string(),
                status: 409,
            });
        }else{
            client.collection::<Board>("boards").delete_one(doc! { "_id": key }, None).await.map_err(|_| MyError {
                message: "Failed to delete board".to_string(),
                status: 500,
            })?;
        }
    }


    client
        .collection::<Board>("boards")
        .insert_one(board, None)
        .await
        .map_err(|e| MyError {
            message: format!("Failed to save board: {}", e),
            status: 500,
        })?;
    Ok(())
}

pub async fn get_board(
    key: &str,
    modified_since: Option<DateTime<FixedOffset>>,
) -> Result<Board, MyError> {
    let client = get_db_connection().await?;
    let filter = doc! { "_id": key };
    let board = client
        .collection::<Board>("boards")
        .find_one(filter, None)
        .await
        .map_err(|e| MyError {
            message: format!("Failed to get board: {}", e),
            status: 500,
        })?;
    match board {
        Some(board) => {
            let last_modified = chrono::DateTime::parse_from_rfc3339(&board.last_modified).unwrap();
            if let Some(modified_since) = modified_since {
                if last_modified <= modified_since {
                    return Err(MyError {
                        message: "Not modified".to_string(),
                        status: 304,
                    });
                }
            }
            Ok(board)
        }
        None => {
            return Err(MyError {
                message: "Board not found".to_string(),
                status: 404,
            })
        }
    }
}


fn board_is_empty(document: &str) -> Result<bool, MyError> {
    let dom = tl::parse(document, tl::ParserOptions::default()).map_err(|_| MyError {
        message: "Failed to parse document".to_string(),
        status: 400,
    })?;
    let children = dom.nodes();
    return Ok(children.len() == 0);
}


pub async fn get_test_board() -> Result<Board, MyError> {
   
   let timestamp = chrono::Utc::now().to_rfc3339();
   #[derive(Deserialize)]
   struct RandomFact {
         text: String,
   }


   let random_fact = reqwest::get("https://uselessfacts.jsph.pl/random.json?language=en").await.map_err(|_| MyError {
        message: "Failed to get random fact for test board".to_string(),
        status: 500,
    })?.json::<RandomFact>().await.map_err(|_| MyError {
        message: "Failed to parse random fact for test board".to_string(),
        status: 500,
    })?;

    let random_color = format!("rgb({},{},{})",rand::random::<u8>(),rand::random::<u8>(),rand::random::<u8>());

   let body = format!(" \
    <time datetime=\"{}\"></time> \
    <div>
        <h1>This is a test board generated by the server</h1>
        <h3> At the time of generation, the server time was {} </h3>
        <p> Enjoy this random fact: </p>
        <p> {} </p>
        <div style=\"background-color:{}; width: 100px; height: 100px;\">

        </div>
    </div>
   ", timestamp,timestamp, random_fact.text, random_color
   );

   let public_key = "ab589f4dde9fce4180fcf42c7b05185b0a02a5d682e353fa39177995083e0583";
   let secret_key = "3371f8b011f51632fea33ed0a3688c26a45498205c6097c352bd4d079d224419";
   let keypair_string = format!("{}{}", secret_key, public_key); 
   let keypair_bytes = hex::decode(keypair_string).unwrap();
   let keypair: Keypair = Keypair::from_bytes(&keypair_bytes).unwrap();
   let signature = keypair.sign(body.as_bytes());
   let signature = hex::encode(signature.to_bytes());

   let board : Board = Board{
        key: public_key.to_string(),
        body: body.to_string(),
        timestamp: chrono::Utc::now().to_rfc3339(),
        last_modified: chrono::Utc::now().to_rfc3339(),
        signature: signature.to_string(),
    };
    Ok(board)
}